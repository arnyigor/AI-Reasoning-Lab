import random
import re
from typing import Dict, Any

from baselogic.tests.abstract_test_generator import AbstractTestGenerator


class CodeGenTestGenerator(AbstractTestGenerator):
    # Пример реализации generate()
    def generate(self) -> Dict[str, Any]:

        prompt = (
            """
            #### Роль и контекст
            Ты — ведущий Python-разработчик с глубоким пониманием современных практик разработки. Твоя экспертиза включает асинхронное программирование с использованием asyncio, проектирование тестируемых и независимых модулей, а также написание чистого и самодостаточного кода в соответствии с принципами SOLID.
            #### Основная задача
            Разработать на Python самодостаточный программный модуль, который решает конкретную задачу. К этому модулю необходимо написать встроенный набор тестов, покрывающий все возможные сценарии использования, включая позитивные, граничные и ошибочные случаи.
            Все проверки должны выполняться через запуск основного скрипта ( if __name__ == "__main__":), который должен выводить в консоль понятный и структурированный результат (успех/ошибка) для каждого теста. Код должен быть полностью автономным и не требовать установки внешних зависимостей (только стандартная библиотека Python).
            Твоё решение будет оценено по корректности, чистоте кода, полноте тестового покрытия и эффективности (скорость выполнения и потребление памяти).
            #### Требования и ограничения
            - Язык: Python (последняя стабильная версия).
            - Асинхронность: Обязательно использовать модуль asyncio для асинхронной обработки, если это уместно в рамках предложенной логики.
            - Код должен быть:
                - Независимым: Не использовать внешние библиотеки (например, pytest, requests, numpy и т.д.). Разрешена только стандартная библиотека Python.
                - Чистым: Соблюдать принципы SOLID и общепринятые конвенции именования (PEP 8).
                - Модульным: Четко отделить бизнес-логику от тестов. Тесты должны быть интегрированы в точку входа для запуска.
            - Тесты должны покрывать:
                - Позитивные сценарии: Проверка корректной работы с валидными данными.
                - Граничные случаи: None, пустые коллекции, нулевые значения, максимальные/минимальные допустимые значения.
                - Ошибочные входные данные: Некорректные типы, неверный формат, отрицательные значения там, где ожидаются положительные.
                - Поведение в условиях конкуренции: Если используется asyncio, проверить корректную обработку одновременных операций, блокировок и состояний гонки.
                - Временные ограничения: Проверить поведение при таймаутах или задержках.
            - Вывод: Результат выполнения тестов должен быть явно виден в консоли (например, "Тест 'test_name': УСПЕХ" / "Тест 'test_name': ОШИБКА с причиной: ...").
            - Запуск: Все тесты запускаются при выполнении скрипта, без необходимости внешних команд или фреймворков.
            - Данные: Если для тестирования не хватает данных, их нужно сгенерировать в достаточном объеме и разнообразии.
            #### Формат ответа
            Ответ должен быть структурирован следующим образом в виде единого блока кода на Python:
            1. Основной код — реализация бизнес-логики (классы, функции, асинхронные операции).
            2. Тестовый фреймворк — минималистичная обвязка для запуска тестов и вывода результатов.
            3. Набор тестов — функции, реализующие проверки, с явным указанием тестируемого сценария в названии или docstring.
            4. Точка входа — блок if __name__ == "__main__":, который запускает все тесты и выводит итоговую статистику.
            Код должен содержать чёткие комментарии, разделяющие эти логические части.
            #### Дополнительные указания
            - Успешная реализация демонстрирует:
                - Полное покрытие всех упомянутых выше сценариев.
                - Корректную и безопасную работу с asyncio (управление задачами, обработка исключений, отмена, таймауты).
                - Чистый итоговый отчет в консоли: сколько тестов выполнено, сколько успешно/неудачно.
            - Если все тесты пройдены успешно, предложи улучшения или варианты оптимизации кода. Если код уже достаточно оптимизирован для поставленной задачи, укажи это.
            - Если присылаешь исправления, СТРОГО присылай весь код целиком (либо всю функцию, либо весь класс), без комментариев в стиле "здесь код без изменений".
            - Отвечай на русском языке.
            
            
            ## Задача
            Роль: Ты — ИИ-ассистент по программированию. Цель: Реши следующую сложную оптимизационную задачу на Python. Твое решение будет оценено по корректности, скорости выполнения и потреблению памяти на нескольких калиброванных тестах.
            #### Условие задачи
            Название: Гибридное облако: Оптимизация затрат на специализированные и универсальные серверы
            Вы проектируете архитектуру для гибридного облака. В системе есть два вида серверов:
            1. Специализированные серверы: Каждый такой сервер привязан к конкретному типу задач (например, type_0, type_1) и может выполнять только их.
            2. Универсальные серверы: Это более дорогие машины, способные выполнять задачу любого типа.
            Вам дан список всех запланированных задач. Каждая задача характеризуется временем начала, временем окончания и своим основным типом. Любую задачу можно выполнить либо на специализированном сервере ее типа, либо "перебросить" на любой свободный универсальный сервер.
            Ваша цель — найти такую стратегию распределения задач, которая минимизирует общее количество задействованных физических серверов. Общее количество равно сумме пикового числа универсальных серверов и пикового числа специализированных серверов по каждому типу.
            Формально: Если вы решили выделить S_0, S_1, ..., S_{M-1} специализированных серверов для каждого из M типов и U универсальных серверов, то ваша цель — минимизировать U + S_0 + S_1 + ... + S_{M-1}.
            Ключевое требование: Решение должно быть оптимальным. Простая эвристика (например, "всегда использовать специализированный сервер, если он свободен") не гарантирует глобального минимума. Алгоритм должен быть способен обработать десятки миллионов задач.
            #### Формат входных данных на Python
            Функция solve_hybrid_cloud  принимает два аргумента:
            1. tasks ( List[List[int]]): Список задач. Каждый элемент — это список из трех целых чисел: [start_time, end_time, server_type_id].
                - 0 <= start_time < end_time <= 2 * 10^9
                - 0 <= server_type_id < num_server_types
                - Количество задач (длина списка tasks) может быть от 0 до 100,000,000.
            2. num_server_types ( int): Общее количество различных типов специализированных серверов.
                - 1 <= num_server_types <= 5000
            #### Формат выходных данных
            Функция должна вернуть одно целое число ( int): минимально возможное общее количество серверов.
            #### Ограничения
            - Время выполнения: не более 30 секунд на сгенерированном наборе из 10,000,000 задач.
            - Использование памяти: не более 6 ГБ.
            - Зависимости: Только стандартная библиотека Python.
            #### Пример
            Вход:
            ```"tasks": [[0, 10, 0], [0, 10, 1]], "num_server_types": 2
            ```
            Выход:
            ```2```
            
            Пояснение: Пиковая нагрузка приходится на интервал [10, 15). В этот момент активны 2 задачи типа 0 и 1 задача типа 1.
            - Стратегия без универсальных серверов: Потребуется 2 специализированных сервера типа 0 и 1 специализированный сервер типа 1. Всего: U=0, S0=2, S1=1 -> 3 сервера.
            - Стратегия с универсальными серверами: Можно "перебросить" одну из задач типа 0 на универсальный сервер. Тогда нам понадобится 1 спец. сервер типа 0, 1 спец. сервер типа 1 и 1 универсальный сервер. Всего: U=1, S0=1, S1=1 → 3 сервера. Минимально возможное общее число — 3.
            #### Ограничения и тесты
            Твое решение будет проверено на нескольких наборах тестов:
            1. Тесты на корректность: Набор из 9 тестов, проверяющих пограничные случаи и логику.
            2. Тест на производительность CPU:
                - Параметры: ~35,000 задач, ~500 типов.
                - Лимит по времени: 30 секунд.
            3. Тест на эффективность по памяти:
                - Параметры: ~70,000 задач, ~1000 типов.
                - Лимит по времени: 120 секунд.
                - Лимит по памяти: 0.015 ГБ.
            """
        )

        return {
            'prompt': prompt,
            'expected_output': {
                'function_name': "solve_hybrid_cloud",
                'tests': ""
            }
        }

    def verify(self, llm_output: str, expected_output: Any) -> Dict[str, Any]:
        # 1. Извлекаем блок кода
        # Удаляем блоки <think>...</think> перед поиском кода
        code_match = re.search(r"```python\n(.*?)\n```", llm_output, re.DOTALL)
        if not code_match:
            code_match = re.search(r"def\s.*", llm_output, re.DOTALL)

        if not code_match:
            return {'is_correct': False, 'details': {'error': 'Блок кода Python не найден в очищенном ответе'}}

        code_to_exec = code_match.group(1) if len(code_match.groups()) > 0 else code_match.group(0)

        # >>>>> НАЧАЛО ИЗМЕНЕНИЙ: "Санитизация" кода <<<<<
        # Заменяем типографские символы на стандартные для Python
        replacements = {
            '—': '-',  # Длинное тире -> Минус
            '‘': "'",  # Левая одинарная кавычка -> Стандартная
            '’': "'",  # Правая одинарная кавычка -> Стандартная
            '“': '"',  # Левая двойная кавычка -> Стандартная
            '”': '"',  # Правая двойная кавычка -> Стандартная
        }
        for old, new in replacements.items():
            code_to_exec = code_to_exec.replace(old, new)
        # >>>>> КОНЕЦ ИЗМЕНЕНИЙ <<<<<

        # 2. Выполняем код и запускаем тесты
        try:
            local_scope = {}
            exec(code_to_exec, {}, local_scope)

            function_name = expected_output['function_name']
            if function_name not in local_scope:
                return {'is_correct': False, 'details': {'error': f'Функция {function_name} не была определена'}}

            for test_case in expected_output['tests']:
                exec(test_case, {}, local_scope)

            return {'is_correct': True, 'details': {'status': 'Все тесты пройдены'}}

        except AssertionError as e:
            return {'is_correct': False,
                    'details': {'error': 'Логическая ошибка (AssertionError)', 'failed_test': str(e)}}
        except Exception as e:
            return {'is_correct': False, 'details': {'error': 'Ошибка синтаксиса или выполнения', 'traceback': str(e)}}
